# Sort

# 🧹 기본적인 정렬 방법

## 1. 선택 정렬 O(N²)

- 특징
    - 매번 '가장 작은 것을 선택'한다는 의미에서 **선택 정렬**<sup>(Selection Sort)</sup> 알고리즘이라고 한다.
    - 데이터가 무작위로 여러 개 있을 때, 이 중에서 가장 작은 데이터를 선택해 맨 앞에 있는 데이터와 바꾸고, 그다음 작은 데이터를 선택해 앞에서 두 번째 데이터와 바꾸는 과정을 반복하는 방법이다.
    - 현재 데이터의 상태와 상관없이 무조건 모든 원소를 비교하고 위치를 바꾼다.
- 과정
    1. 전체에서 제일 작은 데이터를 선택해 맨 앞에 있는 데이터와 스왑한다.
    2. 정렬된 첫 번째는 제외하고 이후 데이터 중에서 가장 작은 데이터를 선택해서 처리되지 않은 데이터 중 가장 앞에 있는 데이터와 바꾼다.
    3. 위의 과정을 반복한다.
- 코드

    ```python
    # 무작위의 데이터
    nums = [1,  3,  2,  4,  6,  5,  8,  7,  9,  0]

    for i in range(len(nums)):
    	# 가장 앞의 데이터로 기준 설정
    	min_index = i

    	for j in range(i + 1, len(nums)):
    	# 기준보다 값이 작은 데이터를 찾으면
    		if nums[min_index] > nums[j]:
    			min_index = j
    			nums[i], nums[min_index] = nums[min_index], nums[i]
     
    print(nums)
    ```

## 2. 삽입 정렬 O(N²)

- 특징
    - 특정한 데이터를 적절한 위치에 '삽입'한다는 의미에서 **삽입 정렬**<sup>(Insertion Sort)</sup>이라고 부른다.
    - 선택 정렬에 비해 구현 난이도가 높긴 하지만 실행 시작 측면에서 더 효율적인 알고리즘이다. 필요할 때만 위치를 바꾸므로 특히 '데이터가 거의 정렬되어 있을 때' 훨씬 효율적이다.
    - 삽입 정렬은 두 번째 데이터부터 시작한다. 왜냐하면 첫 번째 데이터는 그 자체로 정렬되어 있다고 판단하기 때문이다.
- 과정
    1. 첫 번째 데이터는 그 자체로 정렬되어 있다고 판단하고, 두 번째 데이터가 어떤 위치로 들어갈지 판단한다. 첫 번째 데이터의 왼쪽으로 들어가거나 혹은 오른쪽으로 들어가는 두 경우만 존재한다.
    2. 이어서 세 번째 데이터가 어떤 위치에 들어갈지 판단한다. 삽입될 수 있는 위치는 총 3가지이다.
        - 첫 번째 데이터의 왼쪽
        - 두 번째 데이터의 왼쪽
        - 그대로
    3. 위의 과정을 반복한다.
- 코드

    ```python
    # 무작위 데이터
    arr = [7,  5,  4,  6,  2,  3,  1,  0,  8,  9]
      
    for i in range(1, len(arr)):
    # 인덱스 i부터 1까지 감소하며 반복하는 문법
    	for j in range(i, 0, -1):
    		# 한 칸씩 왼쪽으로 이동
    		if arr[j] < arr[j-1]:
    			arr[j], arr[j-1] = arr[j-1], arr[j]
    		# 자기보다 작은 데이터를 만나면 그 위치에서 멈춤
    		else:
    			break
    		
    print(arr)
    ```

## 3. 퀵 정렬 O(NlogN)

- 특징
    - 퀵 정렬은 정렬 알고리즘 중에 가장 많이 사용되는 알고리즘이다. 퀵 정렬과 비교할 만큼 빠른 알고리즘으로 '병합 정렬' 알고리즘도 있다. 대부분의 프로그래밍 언어에서 정렬 라이브러리의 근간이 되는 알고리즘이기도 하다.
    - 퀵 정렬은 기준을 설정한 다음 큰 수와 작은 수를 교환한 후 리스트를 반으로 나누는 방식으로 동작한다. 퀵 정렬은 피벗<sup>Pivot</sup>이 사용된다. 큰 숫자와 작은 숫자를 교환할 때, 교환하기 위한 '기준'을 바로 피벗이라고 표현한다.
    - 피벗을 설정하고 리스트를 분할하는 방법에 따라서 여러가지 방식으로 퀵 정렬을 구분하는데, 가장 대표적인 분할 방식인 호어 분할<sup>Hoare Partition</sup>방식을 기준으로 퀵 정렬을 해보자.
    - 호어 분할 방식에서는 리스트에서 첫 번째 데이터를 피벗<sup>Pivot</sup>으로 정한다.
    - 피벗을 설정한 뒤에는 왼쪽부터 피벗보다 큰 데이터를 찾고, 오른쪽에서부터 피벗보다 작은 데이터를 찾는다. 그다음 큰 데이터와 작은 데이터의 위치를 서로 교환해준다. 이 과정을 반복하면 '피벗'에 대해 정렬이 수행된다.
- 과정
    1. 피벗을 기준으로 리스트의 왼쪽에서부터 피벗보다 큰 데이터를, 오른쪽에서부터 피벗보다 작은 데이터를 찾아 서로의 위치를 교환한다.
    2. 위의 과정을 반복하다 엇갈리는 경우, 작은 데이터와 피벗의 위치를 서로 변경한다.
    3. 2번의 과정이 끝나면 피벗을 기준으로 왼쪽 리스트와 오른쪽 리스트로 나뉘는데, 왼쪽 리스트는 모두 피벗보다 작고, 오른쪽 리스트는 피벗보다 큰 데이터가 위치하게된다. 이를 분할<sup>Divide</sup> 혹은 파티션<sup>Partition</sup>이라고 한다.
    4. 이러한 상태에서 왼쪽 리스트와 오른쪽 리스트를 마찬가지로 각각 피벗을 설정하여 동일한 방식으로 정렬을 수행하면 모두 정렬이 끝이난다.
- 코드

    ```python
    array = [5, 7, 9, 0, 3, 1, 6, 2, 4, 8]

    def quick_sort(array, start, end):
        if start >= end: # 원소가 1개인 경우 종료
            return
        pivot = start # 피벗은 첫 번째 원소
        left = start + 1
        right = end
        while left <= right:
            # 피벗보다 큰 데이터를 찾을 때까지 반복 
            while left <= end and array[left] <= array[pivot]:
                left += 1
            # 피벗보다 작은 데이터를 찾을 때까지 반복
            while right > start and array[right] >= array[pivot]:
                right -= 1
            if left > right: # 엇갈렸다면 작은 데이터와 피벗을 교체
                array[right], array[pivot] = array[pivot], array[right]
            else: # 엇갈리지 않았다면 작은 데이터와 큰 데이터를 교체
                array[left], array[right] = array[right], array[left]
        # 분할 이후 왼쪽 부분과 오른쪽 부분에서 각각 정렬 수행
        quick_sort(array, start, right - 1)
        quick_sort(array, right + 1, end)

    quick_sort(array, 0, len(array) - 1)
    print(array)

    ```