# 🧹 기본적인 정렬 방법

## 1. 선택 정렬 O(N²)
- 특징
	매번 '가장 작은 것을 선택'한다는 의미에서 **선택 정렬**<sup>(Selection Sort)</sup> 알고리즘이라고 한다.
	데이터가 무작위로 여러 개 있을 때, 이 중에서 가장 작은 데이터를 선택해 맨 앞에 있는 데이터와 바꾸고, 그다음 작은 데이터를 선택해 앞에서 두 번째 데이터와 바꾸는 과정을 반복하는 방법이다.
	현재 데이터의 상태와 상관없이 무조건 모든 원소를 비교하고 위치를 바꾼다.    
	
- 과정
	1. 전체에서 제일 작은 데이터를 선택해 맨 앞에 있는 데이터와 스왑한다.
	2. 정렬된 첫 번째는 제외하고 이후 데이터 중에서 가장 작은 데이터를 선택해서 처리되지 않은 데이터 중 가장 앞에 있는 데이터와 바꾼다.
	3. 위의 과정을 반복한다.   
	
- 코드
	```python
	# 무작위의 데이터
	nums = [1,  3,  2,  4,  6,  5,  8,  7,  9,  0]

	for i in range(len(nums)):
		# 가장 앞의 데이터로 기준 설정
		min_index = i

		for j in range(i + 1, len(nums)):
		# 기준보다 값이 작은 데이터를 찾으면
			if nums[min_index] > nums[j]:
				min_index = j
				nums[i], nums[min_index] = nums[min_index], nums[i]
	 
	print(nums)
	```



## 2. 삽입 정렬 O(N²)
- 특징
	특정한 데이터를 적절한 위치에 '삽입'한다는 의미에서 **삽입 정렬**<sup>(Insertion Sort)</sup>이라고 부른다.
	선택 정렬에 비해 구현 난이도가 높긴 하지만 실행 시작 측면에서 더 효율적인 알고리즘이다.
	필요할 때만 위치를 바꾸므로 특히 '데이터가 거의 정렬되어 있을 때' 훨씬 효율적이다.
	삽입 정렬은 두 번째 데이터부터 시작한다. 왜냐하면 첫 번째 데이터는 그 자체로 정렬되어 있다고 판단하기 때문이다.   
	
	
- 과정
	1. 첫 번째 데이터는 그 자체로 정렬되어 있다고 판단하고, 두 번째 데이터가 어떤 위치로 들어갈지 판단한다. 첫 번째 데이터의 왼쪽으로 들어가거나 혹은 오른쪽으로 들어가는 두 경우만 존재한다.
	2. 이어서 세 번째 데이터가 어떤 위치에 들어갈지 판단한다. 삽입될 수 있는 위치는 총 3가지이다.
		- 첫 번째 데이터의 왼쪽
		- 두 번째 데이터의 왼쪽
		- 그대로
	3. 위의 과정을 반복한다.   

	
- 코드
	```python
	# 무작위 데이터
	arr = [7,  5,  4,  6,  2,  3,  1,  0,  8,  9]
	  
	for i in range(1, len(arr)):
	# 인덱스 i부터 1까지 감소하며 반복하는 문법
		for j in range(i, 0, -1):
			# 한 칸씩 왼쪽으로 이동
			if arr[j] < arr[j-1]:
				arr[j], arr[j-1] = arr[j-1], arr[j]
			# 자기보다 작은 데이터를 만나면 그 위치에서 멈춤
			else:
				break
			
	print(arr)
	```



## 3. 퀵 정렬 O(NlogN)

- 특징
	퀵 정렬은 정렬 알고리즘 중에 가장 많이 사용되는 알고리즘이다. 퀵 정렬과 비교할 만큼 빠른 알고리즘으로 '병합 정렬' 알고리즘도 있다. 대부분의 프로그래밍 언어에서 정렬 라이브러리의 근간이 되는 알고리즘이기도 하다.   
	
	퀵 정렬은 기준을 설정한 다음 큰 수와 작은 수를 교환한 후 리스트를 반으로 나누는 방식으로 동작한다.
	퀵 정렬은 피벗<sup>Pivot</sup>이 사용된다. 큰 숫자와 작은 숫자를 교환할 때, 교환하기 위한 '기준'을 바로 피벗이라고 표현한다.
	피벗을 설정하고 리스트를 분할하는 방법에 따라서 여러가지 방식으로 퀵 정렬을 구분하는데, 
	가장 대표적인 분할 방식인 호어 분할<sup>Hoare Partition</sup>방식을 기준으로 퀵 정렬을 해보자.
	호어 분할 방식에서는 리스트에서 첫 번째 데이터를 피벗<sup>Pivot</sup>으로 정한다.
	피벗을 설정한 뒤에는 왼쪽부터 피벗보다 큰 데이터를 찾고, 오른쪽에서부터 피벗보다 작은 데이터를 찾는다.
	그다음 큰 데이터와 작은 데이터의 위치를 서로 교환해준다. 이 과정을 반복하면 '피벗'에 대해 정렬이 수행된다.
	
	
	
- 과정
	1. 
	2. 
		- 
		- 
		- 
	3.   

	
- 코드
	```python
	# 무작위 데이터
	arr = [7,  5,  4,  6,  2,  3,  1,  0,  8,  9]
	  
	for i in range(1, len(arr)):
	# 인덱스 i부터 1까지 감소하며 반복하는 문법
		for j in range(i, 0, -1):
			# 한 칸씩 왼쪽으로 이동
			if arr[j] < arr[j-1]:
				arr[j], arr[j-1] = arr[j-1], arr[j]
			# 자기보다 작은 데이터를 만나면 그 위치에서 멈춤
			else:
				break
			
	print(arr)
	```

