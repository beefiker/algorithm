# 📒 Coding Note / 구현 - 상하좌우



- ##  ⤭ 상하좌우

> + #### 문제 설명
>
>   여행자 A씨는 N x N 크기의 정사각형 공간 위에 서 있다.
>
>   이 공간은 1 x 1 크기의 정사각형으로 나누어져 있다.
>
>   가장 왼쪽 위 좌표는 (1, 1)이며, 가장 오른쪽 아래 좌표는 (N, N)이다.
>
>   여행자 A씨는 상, 하, 좌, 우 방향으로 이동할 수 있으며, 시작 좌표는 항상 (1, 1)이다.
>
>   당신의 앞에는 여행자 A씨가 이동할 계획이 적인 계획서가 놓여 있다.
>
>   
>
>   계획서에는 하나의 줄에 띄어쓰기를 기준으로 하여 L, R, U, D 중 하나의 문자가 반복적으로 적혀있다.
>
>   각 문자의 의미는 Left, Right, Up, Down의 앞문자이다.
>
>   
>
>   이때 여장자 A씨가 N x N 크기의 정사각형 공간을 벗어나는 움직임은 무시된다.
>
>   예를 들어 (1, 1) 위치에서 L, U를 만나면 무시된다. 
>
> 
>
>   ***입력 조건***
>
>   > 첫째 줄에 공간의 크기를 나타내는 N이 주어진다. ( 1 ≦ N ≦ 100 )
>   >
>   > 둘째 줄에 여행자 A씨가 이동할 계획서 내용이 주어진다. ( 1 ≦ 이동횟수 ≦ 100 )
>
> 
>
>   ***출력 조건***
>
>   > 첫째 줄에 여행자 A씨가 최종적으로 도착할 지점의 좌표 (X, Y)를 공백으로 구분하여 출력한다.
>
> 
>
>   - ##### 예시
>
>     > 계획서에는 `R R R U D D`가 적혀있다.
>     >
>     > 이 6개의 명령에 따라 여행자가 움직이게 되는 위치는 순서대로
>     >
>     > `(2, 1) (3, 1) (4, 1) (4, 1) (4, 2) (4, 3) 이므로 최종 좌표는 (4, 3) `이다.
>
> + #### 나의 시도 (성공)
>
>   문제를 보고 충분히 할 수 있을 것 같아서 시도해보았다.
>
>   입력 조건과 출력 조건대로 잘 작동하는 모습이다!! 🤣
>
>   ``` python
>   n = int(input());
>   
>   moves = input().split()
>   x, y = 1, 1;
>   
>   for move in moves:
>       if move == "L":
>           if x>1:
>               x-=1
>       if move == "R":
>           if x<n:
>               x+=1
>       if move == "U":
>           if y>1:
>               y-=1
>       if move == "D":
>           if y<n:
>               y+=1
>       else: continue
>   
>   print(x, y)
>   ```
>
> + #### 답안
>
>   역시 나의 코드와는 다르게 구체적인 느낌이 드는 것 같다.
>
>   dx와 dy에 이동방향을 먼저 정해놓고 move_types와 짝지어서 이동하는 방법이 있구나 하고 깨달았다.
>
>   ``` python
>   # N 입력받기
>   n = int(input())
>   x, y = 1, 1
>   plans = input().split()
>   
>   # L, R, U, D에 따른 이동 방향
>   dx = [0, 0, -1, 1]
>   dy = [-1, 1, 0, 0]
>   move_types = ['L', 'R', 'U', 'D']
>   
>   # 이동 계획을 하나씩 확인
>   for plan in plans:
>       # 이동 후 좌표 구하기
>       for i in range(len(move_types)):
>           if plan == move_types[i]:
>               nx = x + dx[i]
>               ny = y + dy[i]
>       # 공간을 벗어나는 경우 무시
>       if nx < 1 or ny < 1 or nx > n or ny > n:
>           continue
>       # 이동 수행
>       x, y = nx, ny
>   
>   print(x, y)
>   ```
>
>   
>
> + 문제 해설
>
>   이 문제를 요구사항대로 구현하면 연산 횟수는 이동 횟수에 비례한다, 따라서 시간 복잡도는 O(N)이다.
>
> 



​		