
# 📒 Coding Note / DFS - 얼음 얼려먹기

- ### 음료수 얼려먹기
    - #### 문제 설명
        `N x M` 크기의 얼음 틀이 있다. 
        구멍이 뚫려 있는 부분은 `0`, 칸막이가 존재하는 부분은 `1`로 표시된다.
        구멍이 뚫려 있는 부분까리 상, 하, 좌, 우로 붙어 있는 경우 서로 연결되어 있는 것으로 간주한다.
        이때 얼음 틀의 모양이 주어졌을 때 생성되는 총 얼음의 개수를 구하는 프로그램을 작성하시오.
        다음은 `4 x 5` 얼음 틀 예시에서는 얼음이 총 3개 생성된다.
        
    - 입력 조건
        - 첫째 줄에 얼음 틀의 세로 길이 `N`과 가로 길이 `M`이 주어진다. `(  1 ≦ N, M ≦ 1,000 )`
        - 두 번째 줄부터 N + 1번째 줄 까지 얼음 틀의 형태가 주어진다.
        - 이때 구멍이 뚫려있는 부분은 0, 그렇지 않은 부분은 1이다.
    - 출력 조건
        - 한 번에 만들 수 있는 얼음의 개수를 출력한다.
    
    - 입력 예시와 출력 예시
        - 입력 예시
            ```
            00110
            00011
            11111
            00000
            ```
        - 출력 예시
            ```
            3
            ```
                    
    - #### 코드
        ```python
        # 세로길이 N, 가로길이 M 입력받기
        n, m = map(int,  input().split())
          
        graph = []

        # 세로길이 N 만큼 입력받아 2차원 리스트 생성
        for _ in range(n):
            graph.append(list(map(int, input())))
          
        # DFS로 특정한 노드를 방문한 뒤 연결된 모든 노드를 재귀적으로 방문
        def dfs(x, y):
            # 주어진 범위를 벗어나면 즉시 종료
            if x <= -1 or x >= n or y <= -1  or y >= m:
                return  False
              
            # 현재 노드를 방문하지 않았다면
            if graph[x][y]  ==  0:
            # 해당 노드를 방문 처리
                graph[x][y]  =  1
                # 상, 하, 좌, 우 위치의 노드도 모두 재귀적으로 호출
                dfs(x-1, y)
                dfs(x+1, y)
                dfs(x, y-1)
                dfs(x, y+1)
                return  True
            return  False

        count =  0
          
        # 모든 노드에 대해 얼음 채우기
        for i in range(n):
            for j in range(m):
                # 현재 위치에서 DFS 수행
                if dfs(i, j) == True:
                    count += 1
          
        print(count)
        ```
    - #### 문제 해설
        이 문제는 DFS로 해결할 수 있다. 일단 DFS 기초 설명에서 배운 대로 얼음을 얼릴 수 있는 공간이 상, 하, 좌, 우로 연결되어 있다고 표현할 수 있으므로 그래프 형태로 모델링 할 수 있다. 
